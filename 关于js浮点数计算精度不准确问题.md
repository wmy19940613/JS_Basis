## 关于js浮点数计算精度不准确问题

+ 今天在计算总价格（单价*数量）时发现关于js浮点数计算精度不准确问题。以前在做项目的时候也发现过这个问题，当时是加法运算所有给每个数都乘以100，在把两个数的和除以100，能够解决这个问题，但是尤其在乘法运算时这个计算精度不准确的问题很多。上面那个方法已经解决不了了
如下所示：

```
0.1+0.2
0.30000000000000004
(0.1*100+0.1*100)/100
0.2  //加法好使
0.11*1.1
0.12100000000000001
(0.11*100*1.1*100)/10000
0.12100000000000002   //乘法不好使
```

+ 产生浮点数计算精度不准确的原因： 
在计算机角度，计算机算的是二进制，而不是十进制。二进制后变成了无线不循环的数，而计算机可支持浮点数的小数部分可支持到52位，所有两者相加，在转换成十进制，得到的数就不准确了，加减乘除运算原理一样。 

```
十进制 二进制 
0.1 0.0001 1001 1001 1001 ... 
0.2 0.0011 0011 0011 0011 ... 
0.3 0.0100 1100 1100 1100 ... 
0.4 0.0110 0110 0110 0110 ... 
0.5 0.1 
0.6 0.1001 1001 1001 1001 ... 
所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，这时候，我们再把它转换为十进制，就成了 0.30000000000000004。 
```

+ 解决方案： 
1. 方法一： 通过toFixed(num)方法来保留小数。因为这个方法是根据四舍五入来保留小数的，所以最后的计算结果不精确. 

```
(1.0-0.9).toFixed(digits) // toFixed() 精度参数须在 0 与20 之间(digits是精确的小数点后的位数) 
parseFloat((1.0-0.9).toFixed(10)) === 0.1 // 结果为True 
parseFloat((1.0-0.8).toFixed(10)) === 0.2 // 结果为True 
parseFloat((1.0-0.7).toFixed(10)) === 0.3 // 结果为True 
parseFloat((11.0-11.8).toFixed(10)) === -0.8 // 结果为True 
parseFloat((2.22 + 0.1).toFixed(10)) ===2.23 //结果为True 
```

2. 方法二：把要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，计算完以后再降级。具体的我没有实现过。
3. 方法三：Math.floor( xxx * 10 ) / 10 // 精确到小数点后一位 

```
1.11*10 
11.100000000000001 //精度不准确 
Math.floor(1.11*10)/10 // 精确到小数点后一位 
1.1 
```
